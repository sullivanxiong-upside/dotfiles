You are helping me manage and improve the Claude Code auto-approval permissions list.

{{GIT_SAFETY}}

## Context

Claude Code has a permissions system that controls which commands run automatically vs. requiring approval. The configuration is stored in `.claude/settings.json` with the following structure:

```json
{
  "permissions": {
    "allow": [
      "Bash(cat:*)",
      "Bash(ls:*)",
      "WebSearch"
    ],
    "deny": [
      "Read(.env)",
      "Read(./secrets/**)"
    ]
  }
}
```

**Key Facts:**
- Built-in read-only tools (Read, Glob, Grep) never require approval
- Bash commands (even read-only ones) require approval by default
- Pattern syntax: `Bash(command:*)` for prefix matching, `Bash(command *)` for wildcards
- Web tools: `WebSearch`, `WebFetch(domain:example.com)`

## Your Task

Help me iteratively improve and manage the Claude Code auto-approval list. Follow this workflow:

### Phase 1: Discovery Phase

First, understand what the user wants to do:

1. **Read current settings:**
   ```bash
   cat ~/repos/dotfiles/.claude/settings.json
   ```

2. **Ask the user their goal:**
   - Add new commands to the allow list?
   - Review and suggest improvements to current list?
   - Remove commands from the allow list?
   - Understand what commands are being blocked?
   - Add domain-specific tools (npm, pip, cargo, etc.)?
   - Set up project-specific permissions?

### Phase 2: Analysis Phase

Based on the user's goal:

**For adding new commands:**
- Ask what commands they frequently use for read-only operations
- Check if the commands are truly read-only (no file modifications, no destructive actions)
- Suggest related commands they might also want (e.g., if they want `npm list`, suggest `npm view`)
- Consider package managers, git operations, system info, etc.

**For reviewing current settings:**
- Analyze the current allow/deny lists
- Identify any risky patterns (overly broad wildcards)
- Suggest missing common read-only commands
- Check for redundant or conflicting rules
- Validate that deny rules protect sensitive files

**For removing commands:**
- Confirm which commands to remove
- Explain the impact (will require approval going forward)
- Suggest alternatives if appropriate

**For domain-specific tools:**
- Identify the programming languages/tools in use
- Suggest relevant read-only commands for those ecosystems
- Examples:
  - Node.js: npm list, npm view, npm outdated
  - Python: pip list, pip show, poetry show
  - Rust: cargo tree, cargo search
  - Ruby: bundle list, gem list
  - Go: go list, go mod graph

### Phase 3: Planning Phase

Present a clear plan with:

1. **Current State:**
   - Show the current allow list (grouped by category)
   - Show the current deny list
   - Identify any issues or gaps

2. **Proposed Changes:**
   - Commands to add (with justification)
   - Commands to remove (with rationale)
   - Deny rules to add/modify
   - Group changes by category for clarity

3. **Safety Analysis:**
   - Confirm all additions are read-only
   - Highlight any potential risks
   - Explain pattern matching implications
   - Suggest deny rules for sensitive files

4. **Categories of Commands:**
   Organize suggestions into logical groups:
   - File Discovery & Navigation (find, ls, tree, file, pwd)
   - File Reading (cat, head, tail, wc, stat, du)
   - Text Searching (grep, rg, ag, ack)
   - Git Discovery (git status, git log, git diff, etc.)
   - System Info (which, whereis, echo, env, uname, whoami)
   - Package Managers (npm, pip, cargo, bundle, etc.)
   - GitHub CLI (gh pr view, gh issue list, etc.)
   - Web Access (WebSearch, WebFetch)
   - Custom Tools (gwf, cwf, project-specific scripts)

### Phase 4: Confirmation Phase

Present the complete plan:

```markdown
# Claude Code Auto-Approval Update Plan

## Current Configuration

**Allow List (N commands):**
- File Operations: cat, ls, head, tail, ...
- Git: git status, git log, ...
- System: which, echo, ...
- [Other categories]

**Deny List (N rules):**
- .env files
- secrets/ directories
- [Other protections]

## Proposed Changes

### Commands to Add
**Category: [Category Name]**
- `Bash(command:*)` - Justification
- `Bash(command2:*)` - Justification

### Commands to Remove (if any)
- `Bash(command:*)` - Reason for removal

### Deny Rules to Add/Modify
- `Read(pattern)` - Protection rationale

## Safety Analysis

✓ All additions are read-only operations
✓ No destructive commands included
⚠ [Any concerns or notes]

## Testing Plan

After applying changes, test that:
1. New commands run without approval
2. Sensitive operations still require approval
3. Deny rules block access appropriately
```

**Ask for explicit confirmation before implementing.**

### Phase 5: Implementation Phase

Once confirmed:

1. **Backup current settings:**
   ```bash
   cp ~/repos/dotfiles/.claude/settings.json ~/repos/dotfiles/.claude/settings.json.backup
   ```

2. **Apply changes:**
   - Use Edit tool to modify .claude/settings.json
   - Maintain proper JSON formatting (no comments in JSON!)
   - Keep allow list organized by category for readability
   - Preserve existing settings (statusLine, etc.)

3. **Verify the changes:**
   - Show the updated allow list
   - Confirm JSON is valid
   - Highlight what changed

4. **Provide testing guidance:**
   ```bash
   # Restart Claude Code session for changes to take effect

   # Test new commands work without approval:
   [command examples]

   # Verify sensitive operations still blocked:
   [test denied operations]
   ```

5. **Document for future reference:**
   Create a summary of the permission strategy for the project

## Command Categories Reference

### Safe Read-Only Commands by Ecosystem

**Universal File Operations:**
- find, ls, tree, file, pwd, realpath
- cat, head, tail, less, more
- wc, stat, du, df
- grep, rg, ag, ack, fzf

**Git (Read-Only):**
- git status, git log, git diff, git show
- git branch, git remote, git ls-files
- git config --get, git rev-parse
- git blame, git describe

**System Information:**
- which, whereis, type, command -v
- echo, printf, env, printenv
- uname, whoami, hostname, date
- ps, top, uptime (if monitoring needed)

**Node.js/JavaScript:**
- npm list, npm ls, npm view, npm outdated, npm search
- yarn list, yarn info, yarn why
- pnpm list, pnpm why

**Python:**
- pip list, pip show, pip search
- poetry show, poetry check
- conda list, conda search

**Rust:**
- cargo tree, cargo search, cargo metadata
- rustc --version, cargo --version

**Ruby:**
- bundle list, bundle show
- gem list, gem search

**Go:**
- go list, go mod graph, go version

**Java/JVM:**
- mvn dependency:tree
- gradle dependencies

**Docker (Read-Only):**
- docker ps, docker images, docker inspect
- docker stats, docker version

**GitHub CLI:**
- gh pr view, gh pr list, gh pr checks
- gh issue view, gh issue list
- gh repo view, gh release view

**Custom Tools:**
- Your project-specific read-only scripts
- gwf inspect, gwf status
- cwf commands (as appropriate)

## Security Best Practices

1. **Never auto-approve:**
   - Commands that modify files (write, rm, mv, cp)
   - Commands that execute code (eval, exec, python script.py)
   - Commands that change state (git commit, npm install, pip install)
   - Network operations that send data (curl POST, wget, ssh)
   - Package installations or updates

2. **Always protect sensitive files:**
   ```json
   "deny": [
     "Read(.env)",
     "Read(.env.*)",
     "Read(./secrets/**)",
     "Read(**/.env)",
     "Read(**/credentials.json)",
     "Read(**/id_rsa)",
     "Read(**/.aws/credentials)"
   ]
   ```

3. **Be specific with patterns:**
   - ✓ `Bash(git status:*)` - Only git status commands
   - ✗ `Bash(git *)` - All git commands (too broad!)
   - ✓ `Bash(npm list:*)` - Only npm list
   - ✗ `Bash(npm *)` - Includes npm install (dangerous!)

4. **Test the configuration:**
   - Verify read-only commands work without approval
   - Test that write operations still require approval
   - Check deny rules block sensitive files

## Examples

### Example 1: Adding Package Manager Commands

```json
{
  "permissions": {
    "allow": [
      "Bash(npm list:*)",
      "Bash(npm ls:*)",
      "Bash(npm view:*)",
      "Bash(npm outdated:*)",
      "Bash(pip list:*)",
      "Bash(pip show:*)",
      "Bash(cargo tree:*)"
    ]
  }
}
```

### Example 2: Adding Git Read-Only Operations

```json
{
  "permissions": {
    "allow": [
      "Bash(git status:*)",
      "Bash(git log:*)",
      "Bash(git diff:*)",
      "Bash(git show:*)",
      "Bash(git branch:*)",
      "Bash(git remote:*)"
    ]
  }
}
```

### Example 3: Adding Web Tools for Documentation

```json
{
  "permissions": {
    "allow": [
      "WebSearch",
      "WebFetch(domain:github.com)",
      "WebFetch(domain:docs.python.org)",
      "WebFetch(domain:developer.mozilla.org)"
    ]
  }
}
```

## Common Patterns

### Pattern 1: Full Read-Only Stack for Web Development

Node.js, Git, GitHub, system info - everything needed for exploration.

### Pattern 2: Data Science Environment

Python, pip, conda, jupyter commands for notebook development.

### Pattern 3: DevOps/Infrastructure

Docker inspect, kubectl get, terraform show - read-only infrastructure tools.

### Pattern 4: Minimal Security-First

Only the bare essentials - cat, ls, git status. Require approval for everything else.

## Troubleshooting

**Commands still requiring approval:**
- Check pattern syntax (command:* for prefix, * for wildcard)
- Verify command name matches exactly
- Restart Claude Code session
- Check for typos in settings.json

**Too permissive:**
- Review patterns for overly broad wildcards
- Add deny rules for sensitive locations
- Consider splitting broad patterns into specific commands

**JSON validation errors:**
- Remove comments (JSON doesn't support comments)
- Check for trailing commas
- Validate quotes and brackets
- Use a JSON formatter to check syntax

{{FILE_READING_REMINDER}}
