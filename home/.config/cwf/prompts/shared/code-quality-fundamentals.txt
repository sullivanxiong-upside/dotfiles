Code Quality Fundamentals

## Constants & Configuration
- Define constants in dedicated files (constants.py/ts) or at top of file
- Use UPPER_CASE naming and enums for related values
- Never scatter magic numbers/strings throughout code
- Single source of truth for each value

## Configuration Management
- Extract configurable values to config files (don't hardcode in logic)
- Use existing config structure if available, create new config file if needed
- Config file location: config/[domain].yaml, config/[feature].json, etc.
- Examples: timeouts, rate limits, feature flags, API endpoints, thresholds
- Keep environment-specific configs separate (dev/staging/prod)

## Type Safety
- Annotate all function parameters and return types
- Use strict type checking (mypy, TypeScript strict mode)
- Avoid 'any' or dynamic types unless necessary
- Prefer type-safe patterns (discriminated unions, enums)

## Error Handling
- Use specific exception types, not generic Exception/Error
- Handle expected errors explicitly (try/catch for known failures)
- Let unexpected errors propagate to global handlers
- Always clean up resources (use context managers/finally/defer)

## Code Organization
- Functions should do one thing and do it well
- Keep functions under 50 lines when possible
- Extract when you see 2+ similar code blocks
- Group related functions/classes into modules

## Naming
- Use descriptive names that reveal intent
- Avoid abbreviations except for well-known terms
- Boolean variables: is/has/should prefix (isValid, hasPermission)
- Functions: verb prefix (getUser, calculateTotal, validateInput)

## Dependencies
- Inject dependencies via constructor/parameters
- Don't instantiate dependencies inside classes
- Follow existing DI patterns in the codebase

## Simplicity Principle

**Prefer built-in tools and simple solutions over custom implementations.**

When solving a problem:
1. Check if shell commands or existing tools can do it
2. Use one-liners (sleep + command) over custom scripts when possible
3. Don't create abstractions for one-time operations
4. If it's doable via CLI, use CLI

**Examples:**

✅ **Simple:**
```bash
# Wait 5 minutes, then check status
sleep 300 && curl http://api/status
```

❌ **Overcomplicated:**
```python
# Custom polling script with retries, exponential backoff, etc.
# for a one-time status check
```

✅ **Simple:**
```bash
# Filter JSON with jq
cat data.json | jq '.results[] | select(.status == "success")'
```

❌ **Overcomplicated:**
```python
# Custom Python script to parse and filter JSON
# when jq does it in one line
```

**When custom tools ARE appropriate:**
- Reusable across multiple workflows
- Complex business logic that can't be expressed simply
- Type safety and validation are critical
- Integration with existing systems requires structure

**Guideline:** Start simple. Only add complexity when you've proven the simple solution won't work.

## Review Checklist
- No magic numbers/strings
- Configurable values in config files, not hardcoded
- All public functions have type annotations
- Error handling uses specific exception types
- Functions are focused and well-named
- Resources are properly cleaned up
- Solution is as simple as possible (prefer built-in tools)
